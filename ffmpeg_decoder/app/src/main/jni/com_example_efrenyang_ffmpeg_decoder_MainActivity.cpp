/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_example_efrenyang_ffmpeg_decoder_MainActivity */
#include <stdio.h>
#include <time.h>

#ifdef __cplusplus
extern "C" {
#endif
#include "include/libavcodec/avcodec.h"
#include "include/libavformat/avformat.h"
#include "include/libswscale/swscale.h"
#include "include/libavutil/avutil.h"
#include "include/libavutil/imgutils.h"
#include "include/libavutil/log.h"

#ifdef ANDROID
#include <android/log.h>
#define LOGE(format, ...) __android_log_print(ANDROID_LOG_ERROR, "(>_<)", format, ##__VA_ARGS__)
#define LOGI(format, ...) __android_log_print(ANDROID_LOG_INFO, "(^_^)", format, ##__VA_ARGS__)
#else
#define LOGE(format, ...) printf("(>_<)" format "\n", ##__VA_ARGS__)
#define LOGI(format, ...) printf("(^_^)" format "\n", ##__VA_ARGS__)
#endif

//Output ffmpeg's av_log()
void custom_log(void *ptr, int level, const char* fmt, va_list vl)
{
    FILE *fp = fopen("storage/emulate/0/av_log.txt", "a+");
    if (fp)
    {
        vfprintf(fp, fmt, vl);
        fflush(fp);
        fclose(fp);
    }
}
/*
 * Class:     com_example_efrenyang_ffmpeg_decoder_MainActivity
 * Method:    decode
 * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jint JNICALL Java_com_example_efrenyang_ffmpeg_1decoder_MainActivity_decode
  (JNIEnv *env, jobject thiz, jstring urlinput, jstring urloutput)
{
    AVFormatContext     *pFormatCtx;
    AVCodecContext      *pCodecCtx;
    AVCodec             *pCodec;
    AVFrame             *pFrame, *pFrameYUV;
    AVPacket            *packet;
    SwsContext          *img_sws_ctx;
    int                 ret, got_picture;
    int                 i, videoindex;
    int                 fmt_cnt = 0;
    FILE                 *out_file = NULL;
    uint8_t              *out_buffer = NULL;
    char                input_str[512] = {0};
    char                output_str[512] = {0};
    char                info[1024] = {0};

    sprintf(input_str, "%s", env->GetStringUTFChars(urlinput, NULL));
    sprintf(output_str, "%s", env->GetStringUTFChars(urloutput, NULL));

    av_log_set_callback(custom_log);

    av_register_all();
    avformat_network_init();
    pFormatCtx = avformat_alloc_context();
    if (!pFormatCtx)
    {
        LOGE("can not alloc memory.\n");
        return -1;
    }

    ret = avformat_open_input(&pFormatCtx, input_str, NULL, NULL);
    if (ret < 0)
    {
        LOGE("avformat open input error code %d\n", ret);
        return -1;
    }

    ret = avformat_find_stream_info(pFormatCtx, NULL);
    if (ret < 0)
    {
        LOGE("avformat find stream info error code %d\n", ret);
        return -1;
    }

    for (int i = 0; i < pFormatCtx->nb_streams; ++i) {
        if (pFormatCtx->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        {
            videoindex = i;
        }
    }
    pCodecCtx = pFormatCtx->streams[i]->codec;

    pCodec = avcodec_find_decoder(pCodecCtx->codec->id);
    if (!pCodec)
    {
        LOGE("find decoder %s error\n", avcodec_get_name(pCodecCtx->codec->id));
        return -1;
    }

    pFrameYUV = av_frame_alloc();
    pFrame = av_frame_alloc();
    out_buffer = (uint8_t *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx->width, pCodecCtx->height, 1));
    if (!out_buffer)
    {
        LOGE("malloc buffer %d:%d error\n", pCodecCtx->width, pCodecCtx->height);
        return -1;
    }
    ret = av_image_fill_arrays(pFrameYUV->data, pFrameYUV->linesize, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx->width, pCodecCtx->height, 1);
    if (ret < 0)
    {
        LOGE("av image fill arrays error\n");
        return -1;
    }
    out_file = fopen(output_str, "wb");
    if (!out_file)
    {
        LOGE("open file error %d\n", errno);
        return  -1;
    }
    img_sws_ctx = sws_getContext(pCodecCtx->width, pCodecCtx->height, *(pCodec->pix_fmts), pCodecCtx->width, pCodecCtx->height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);
    if (!img_sws_ctx)
    {
        LOGE("sws get context error\n");
        return -1;
    }
    while(1)
    {
        ret = av_read_frame(pFormatCtx, packet);
        if (ret < 0)
            break;

        if (packet->stream_index == videoindex)
        {
            avcodec_decode_video2(pCodecCtx, pFrame, &got_picture, packet);
            if (got_picture)
            {
                sws_scale(img_sws_ctx, (const uint8_t* const*)pFrame->data, pFrame->linesize, 0, pFrame->height, pFrameYUV->data, pFrameYUV->linesize);

                fwrite(pFrameYUV->data[0], 1, pFrameYUV->width*pFrameYUV->height, out_file);
                fwrite(pFrameYUV->data[1], 1, pFrameYUV->width*pFrameYUV->height/4, out_file);
                fwrite(pFrameYUV->data[2], 1, pFrameYUV->width*pFrameYUV->height/4, out_file);

                char pictype_str[10]={0};
                switch (pFrameYUV->pict_type) {
                    case AV_PICTURE_TYPE_I:
                        sprintf(pictype_str, "I");
                        break;
                    case AV_PICTURE_TYPE_B:
                        sprintf(pictype_str, "B");
                        break;
                    case AV_PICTURE_TYPE_P:
                        sprintf(pictype_str, "P");
                        break;
                    default:
                        sprintf(pictype_str, "Other");
                        break;
                }
                LOGI("Frame Index:%5d Type %s", fmt_cnt, pictype_str);
                fmt_cnt ++;
            }
        }
    }

    while(1)
    {
        ret = avcodec_decode_video2(pCodecCtx, pFrame, &got_picture, NULL);\
        if (ret < 0)
            break;

        if (!got_picture)
            break;

        sws_scale(img_sws_ctx, (const uint8_t* const*)pFrame->data, pFrame->linesize, 0, pFrame->height, pFrameYUV->data,
                  pFrameYUV->linesize);

        fwrite(pFrameYUV->data[0], 1, pFrameYUV->width * pFrameYUV->height, out_file);
        fwrite(pFrameYUV->data[1], 1, pFrameYUV->width * pFrameYUV->height / 4, out_file);
        fwrite(pFrameYUV->data[2], 1, pFrameYUV->width * pFrameYUV->height / 4, out_file);
        char pictype_str[10] = {0};
        switch (pFrameYUV->pict_type) {
            case AV_PICTURE_TYPE_I:
                sprintf(pictype_str, "I");
                break;
            case AV_PICTURE_TYPE_B:
                sprintf(pictype_str, "B");
                break;
            case AV_PICTURE_TYPE_P:
                sprintf(pictype_str, "P");
                break;
            default:
                sprintf(pictype_str, "Other");
                break;
        }
        LOGI("Frame Index:%5d Type %s", fmt_cnt, pictype_str);
        fmt_cnt++;
    }

    sws_freeContext(img_sws_ctx);
    av_frame_free(&pFrame);
    av_frame_free(&pFrameYUV);
    avcodec_close(pCodecCtx);
    avformat_close_input(&pFormatCtx);
    avformat_free_context(pFormatCtx);
    av_free(out_buffer);
    return 0;
}

#ifdef __cplusplus
}
#endif
